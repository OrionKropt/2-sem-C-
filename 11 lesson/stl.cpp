#include <iostream>
#include <list>
#include <forward_list>
#include <stack>
#include <queue>
#include <deque>

using namespace std;


// Раскзать из stl основыне методы у list, forwardlist stack (разница реализации на списке и на листе) queue это мне 

int main()
{
	list<int, vector<int>> List;
	forward_list<int> fList;
	stack<int> Stack;
	queue<int> Queue;
	deque<int> dQeue;
	
	//----------------------------------------------------------------------------------------------
	
	// У листа нету перегрузки оператора []
	List.push_back(1);  // добавляет в конец
	List.push_front(2); // добаваляет в начало
	List.pop_back();    // Удаляет последний эллемент списка
	List.pop_front();   // Удаляет последний эллемент списка

	List.size();        // Размер списка

	List.reverse();     // Переворачивает список 1 2 3 4 -> 4 3 2 1


	List.clear();       // Удаляет все эллементы 
						
						// Добавялет эллемент в список по указателю в списке
	List.insert(List.begin(), 2);

						// Более быстрая версия insert() добвлен в C++11
	List.emplace(List.begin(), 1);


						// Удаляет эллемент в список по указателю в списке
	List.erase(List.begin());
	// List.begin() возвращает итератор на первый эллемент списка
	// Итератор это указатель на эллемент контейнера
	// Итераторы есть у всех контейнеров stl
	// С помощью них можно обращаться к эллментам контейнера
	// Пример
	// List.end() возврашает указатель на эллемент после последнего эллемента
	// Тоесть если у нас 4 эллемента, то List.end() вернет укзатель на пятый
	auto iter = List.begin();
	for (auto iter = List.begin(); iter != List.end(); ++iter)
		cout << *iter << endl;
	
	List.remove(21);    // Удаляет число которое мы указали
						// Если такого эллемента нету то ничего не пройизойдет

	List.assign(5, 99); // Очищает лист, а затем добавляет пять раз чило 99
	// Это метод имеет несколько перегрузок, благодаря которым,
	// можно копировать один list  в другой
	// Пример
	list<int> List2{ 1, 2, 3, 4 };
	List.assign(List2.begin(), List2.end());
	// После вызова этого метода в List будут скопированы все эллементы List2
	
	//----------------------------------------------------------------------------------------------
						// Добавляет эллемент в слудующим после переданного итертора
	fList.insert_after(fList.begin(), 2); 
	// insert_after() работает так изза особенности односвязного списка
	// В односвязном списке есть указтель только на следющий эллемент
	// 
	// Все меоды с суффиксом after выпоняют свое действие после указанного итератора
						// Добавляет в начало
	fList.push_front(1);

	fList.pop_front();  // Удаляет первый эллемент

	fList.before_begin();
						// Возварщает итерратор на кусочек памяти перед первым эллементом
		// Это нужно, например, для удаления первого эллемента

	//-----------------------------------------------------------------------------------------------
	
	// Это гибрид листа и вектора 
	// Лист из векторов
	// Есть все методы листа и вектора
	// 
	
	//------------------------------------------------------------------------------------------------
	
	//
	// stack, queue, priorety_queue это адаптеры над котнейнерами
	//

	// stack

	Stack.push(1);
	Stack.pop();
	Stack.emplace(1); // Работает быстрее так как создает новый объект прямо в стркутру без копирования
					  // Добавлен в стандарте С++17
					  
	auto a = Stack._Get_container();
					  // Вернет тип контейнера на котором создан Stack
				      // Поумолчанию это deque	
					  
	// Поссле этого мы сможем пользоваться контейнером на котором основан Stack 

	stack<int, list<int>> LStack;
	auto b = LStack._Get_container();
					  // Получили list<int> 

	// queue, priorety_queue
	
	// Может основываться на vector, deque, list
	// 
	// Ограничивает функционал до принципа очереди
	//

	Queue.push(1);   // Добавить эллементв начало
	Queue.emplace(); // То же что и push только современее
	Queue.back();    // Вернет последний эллемент
	Queue.pop();     // Удалит последний эллемент
	Queue.front();   // Вернет первый эллемент

	return 0;
}