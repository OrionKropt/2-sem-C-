///////
///////  1. space invader Timus 2099 решить (Тяжело)
///////  
///////  2. Timus 1444 (несложно)
/////// 
///////  Приводят на пле грифа а там растут тыквы с координатами
/////// Мутим клас Point, Scene -> колчиство тыкв и методы для решения задачи
/////// Гриф должен сьесть как можно больше, ессли он наткнулся на свои следы то алгоритм закончен
/////// По факту нужно найти максимально длинную ломанную линию без самопересечения
/////// 
/////// Проходим по всем точкам и считаем коссинусы и сортируем в порядке возрастания
/////// 
/////// 3. Написать класс поленом (многочлен) над полем по модулю 3 ( коэфы 0, 1, 2)
/////// В нем есть:
/////// Поля:
///////		Страшая степень
///////		массив коэфицеентов
/////// Методы:
///////		Print()
///////		Конструктор
///////		Ввод по коэфам (можно пропускать нулики)
///////		Вычисление значения полинома в точке
///////		Сложение двух многочленов
///////		Деление многочлена столбиком
///////		Опредление неприводимости многочлена
///////		Зашифровать с помощью многочлена текст (по-желанию)
/////// 
/////// 
/////// 
/////// 
//
#include <iostream>
#include "polynomial.h"
using namespace std;


int main()
{
	int* arr = new int[4] {1, 2, 2, 2};
	int* arr2 = new int[2] {1, 2};
	Polynomial pol(3, arr);
	Polynomial pol1(1, arr2);
	//pol.Init();
	pol.View();
	//pol1.Init();
	pol1.View();
	Polynomial pol2 = pol + pol1;
	cout << "pol + pol2 = ";
	pol2.View();
	//Polynomial pol(2);
	//cout << "PointValue() ";
	//cout << pol.PointValue(2) << endl;

	Polynomial remainder;
	pol.DivideIntoPolynomial(pol1, remainder);
	cout << "pol" << endl;
	pol.View();
	cout << "reminder" << endl;
	remainder.View();
	return 0;
}


//
  