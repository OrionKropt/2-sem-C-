#include <iostream>

using namespace std;



// Priorety Queue
//
// Пирамидальная сортировка (heapsort) O(log(n))
// 
// Есть массив чисел  2 1 4 11 7 18
// 
// строим дерево  вида          2
//                           1     4
//                        11   7 18
// 
// Эллемент не является лситом(узел без узлов), если номер эллемента в массиве i: 1 <= i <= N/2, N = size(arr)
// 
// Пирамида сортирущая если каждый эллемент >= своих потомков, у нас не сортирущая
// 
// Делаем сортирующей
// 
// Процедура Sift(i, j), j - размер массива
// 
// при этом if (i <= j/2)
// 
// Идем с низу вверх и влево с эллемента кооторые не явлются листами
// 
// берем наибольшого потомка если он больше ролителя то меняем и запускаем sift для для потомка
// 
// 
// 1.                           2
//                           1     18
//                        11   7 4
// 
// 2.                           2
//                           11    18
//                         1   7 4
// 
// 3.                            18
//                           11     4
//                         1    7 2
// 
// 
// Priorety Queue  Миша
// 
// В дереве хранятся значения но строится по приоритетам
// 
// при вытаскивании эллемента из очереди вызываем sift(i, N)
// и вытаскиваем корень он бдует arr[0]
// 
// 
// Задача 
// есть массив 7*6
// 
// В этой оббласти есть лабиринт вида 
// * - стена
// . - проход
// *****..
// *.*.**.
// 
// создаем матрицу 7 * 6 так: Если * то 0, если . - номер точки 1, 2, ... n Эрик
// Создать матрицу смежности по этому массиву
// 
// 
// Чек книгу!
// 
// class graph  
// {
// 
// bool** матрица смежности
// 
// 
// методы:
// Опредлеить Эллеров путь - порядок номеров вершин, Тимус Гипперканалы
// Построить Эллеров путь: 
// 1 Вар
// Змея откусывающая свой хвост
// Когда она сьедает грань, на матрице смежности ставим 0
// И добавляем в очередь вершину
// Если нечего есть то выталкиваем хвост очереди пушим в голову
// 
// 2 Вар
// 
// Есть два стека
// SW
// SRez
// 
// идем по матрице смежности
// есои есть пути то пушим в SW номера ячекйки матрицы смежности
// Если идти ннекуда то вытаскиваем head стека SW и пушим в SRez
// 
// 
// 
// }
//
// Степень вершины это количество граней которые приходя в нее
// 
// Если есть вершина со нечетной степенью то он не Эйллеров
// 
// Граф Эйллеров если мы проходим все ребра только один раз и можем пройти по всем ребрам 
// 
// 
// Система непересакющихся множеств Маша
// 
// 
// 
// Поиск в графе BFS - поиск в ширину (Волновой алгоритм)
// 
// Нужны Граф, массив поссещенных вершин(можно хранить массив num длинны n) и хранить ее номер
// Очередь
// 
// алгоритм
// Пока очередь не пустая
// берем вершину из очереди и пушим детей, если не были в них
// идем на следеющиию итерацию
// 
// конец
//


class Graph
{
private:
	bool** arr;
	int size;
public:
	Graph(int size) : size(size)
	{
		cout << "Enter adjacency matrix:\n";
		arr = new bool*[size];
		for (int i = 0; i < size; i++)
			arr[i] = new bool[size];
		for (int i = 0; i < size; i++)
			for (int j = 0; j < size; j++)
				cin >> arr[i][j];
	}
	
	bool Euler()
	{
		for (int i = 0; i < size; i++)
		{
			int pow = 0;
			for (int j = 0; j < size; j++)
				if (arr[i][j]) pow++;
			if (pow & 1) return true;
			return false;
		}
	}

};


int main()
{

	return 0;
}